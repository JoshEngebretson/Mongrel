//**************************************************************************
//**
//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
//**       #    ##    ##    #      ####     ####   ##       ##
//**
//**    $Id: PlayerEx.vc 4373 2011-02-27 17:22:59Z firebrand_kh $
//**
//**    Copyright (C) 1999-2006 Jānis Legzdiņš
//**
//**    This program is free software; you can redistribute it and/or
//**  modify it under the terms of the GNU General Public License
//**  as published by the Free Software Foundation; either version 2
//**  of the License, or (at your option) any later version.
//**
//**    This program is distributed in the hope that it will be useful,
//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//**  GNU General Public License for more details.
//**
//**************************************************************************

class PlayerEx : BasePlayer
	abstract;

//
// Player internal flags, for cheats and debug.
//
enum
{
	CF_NOCLIP			= 1 << 0,		// No clipping, walk through barriers.
	CF_GODMODE			= 1 << 1,		// No damage, no health loss.
	CF_REGENERATION		= 1 << 2,		// Regenerate Health points.
	CF_FRIGHTENING		= 1 << 3,		// Scare monsters away.
	CF_DOUBLEFIRINGSPEED= 1 << 4,		// Player owns a double firing speed artifact
	CF_HIGHJUMP			= 1 << 5,		// Player owns a high jump artifact
	CF_TIMEFREEZE		= 1 << 6		// Player owns a time freeze artifact
};

const float USERANGE		= 64.0;
const float USETHINGRANGE	= 128.0;

const float BLINKTHRESHOLD	= 4.0;

// 16 pixels of bob
const float MAXBOB			= 4.0;

const int MAXHEALTH			= 100;
const int MAXMORPHHEALTH	= 30;

// For screen flashing (red or bright).
float			DamageFlash;
float			BonusFlash;

// Base height above floor for viewz.
float			ViewHeight;
// Bob/squat speed.
float			DeltaViewHeight;
// bounded/scaled total momentum.
float			Bob;

// Who did damage (none for floors/ceilings).
EntityEx		Attacker;

float			JumpTime;
int				LocalQuakeHappening;

TVec			MoveDir;

float			LastSectorDamageTime;

float			HazardTime;
float			LastHazardTime;

// Bit flags, for cheats and debug.
// See cheat_t, above.
int				Cheats;

// Refired shots are less accurate.
int				Refire;

float			FlyHeight;

array<name>		RevealedMaps;

float			InventoryTime;
int				ArtifactFlash;
int				InvSize;

bool			onground;
//	Revert camera if player moves.
bool			bRevertCamera;
//	Player cannot move.
bool			bFrozen;
//	Player cannot do anything except press use.
bool			bTotallyFrozen;
//	Monster don't target
bool			bNoTarget;
//	Switch weapons instantly.
bool			bInstantWeaponSwitch;
//	Player is flying
bool			bFly;
//	Inventory bar is always open
bool			bInventoryAlwaysOpen;
//	Auto aiming
bool			bAutoAim;

int				PoisonCount;	// screen flash for poison damage
float			LastPoisonTime;
EntityEx		Poisoner;		// none for non-player mobjs
PlayerEx		PoisonerPlayer;	// for KArena

int				Objectives;

float			MorphTime;	// player is morphed into something if > 0
int				MorphStyle;
class<Actor>	UnmorphFlash;

int				Accuracy;
int				Stamina;

float			BlendR;
float			BlendG;
float			BlendB;
float			BlendA;

int				ChickenPeck;	// chicken peck countdown

Actor			Rain1;	// active rain maker 1
Actor			Rain2;	// active rain maker 2

const int MAX_MAPS_VISITED = 100;

name			MapsVisited[MAX_MAPS_VISITED];

float			FOV;			// current Field Of Vision
float			DesiredFOV;		// desired Field Of Vision

replication
{
	reliable if (!bIsClient)
		Cheats, InventoryTime, ArtifactFlash,
		Objectives, MorphTime, Accuracy, Stamina, MapsVisited, DamageFlash,
		BonusFlash, Attacker, bFrozen, bTotallyFrozen, DesiredFOV, FOV;

	unreliable if (!bIsClient)
		ParticleEffect, ClientExplosion, ClientParticleExplosion,
		ClientSparkParticles, ClientRailTrail;

	reliable if (!bIsClient)
		ClientVoice, ClientSpeech, ClientFinaleType, ClientSlideshow1,
		ClientSlideshow2, SetFOV;

	reliable if (bIsClient)
		bAutoAim;
}

//==========================================================================
//
//  ThrustPlayer
//
//  Moves the given origin along a given angle.
//
//==========================================================================

final void ThrustPlayer(float angle, float move, float deltaTime)
{	
	if (MO.Origin.z <= MO.FloorZ &&
		((EntityEx(MO).GetFloorType()->Friction &&
		EntityEx(MO).GetFloorType()->Friction < EntityEx::FRICTION_NORMAL) ||
		(MO.Sector->special & SECSPEC_BASE_MASK) == SECSPEC_FrictionLow))
	{
		move *= LineSpecialGameInfo(Level.Game).IceMoveFactor;
	}
	MO.Velocity.x += move * cos(angle) * deltaTime;
	MO.Velocity.y += move * sin(angle) * deltaTime;
}

//==========================================================================
//
//  CalcHeight
//
//  Calculate the walking / running height adjustment
//
//==========================================================================

final void CalcHeight(float deltaTime)
{
	float angle;
	float bob;

	// Regular movement bobbing
	// (needs to be calculated for gun swing even if not on ground)
	Bob = MO.Velocity.x * MO.Velocity.x + MO.Velocity.y * MO.Velocity.y;
	Bob /= 4.0 * 35.0 * 35.0;
	if (Bob > MAXBOB)
		Bob = MAXBOB;

	if (MO.bFly && !onground)
	{
		Bob = 0.5;
	}

	angle = 180.0 * 35.0 / 10.0 * Level.XLevel.Time;
	bob = Bob / 2.0 * sin(angle);

	// move viewheight
	if (PlayerState == PST_LIVE)
	{
		ViewHeight += DeltaViewHeight * deltaTime;

		if (ViewHeight > PlayerPawn(MO).ViewHeight)
		{
			ViewHeight = PlayerPawn(MO).ViewHeight;
			DeltaViewHeight = 0.0;
		}

		if (ViewHeight < PlayerPawn(MO).ViewHeight / 2.0)
		{
			ViewHeight = PlayerPawn(MO).ViewHeight / 2.0;
			if (DeltaViewHeight <= 0.0)
				DeltaViewHeight = 0.00001;
		}

		if (DeltaViewHeight)
		{
			DeltaViewHeight += 256.0 * deltaTime;
			if (!DeltaViewHeight)
				DeltaViewHeight = 0.00001;
		}
	}
	ViewOrg.z = MO.Origin.z + ViewHeight + bob;

	if (PlayerState != PST_DEAD && MO.Origin.z <= MO.FloorZ)
	{
		ViewOrg.z -= MO.FloorClip;
	}
	if (ViewOrg.z < MO.FloorZ + 4.0)
		ViewOrg.z = MO.FloorZ + 4.0;

	if (ViewOrg.z > MO.CeilingZ - 4.0)
		ViewOrg.z = MO.CeilingZ - 4.0;
}

//==========================================================================
//
//  MovePlayer
//
//==========================================================================

final void MovePlayer(float deltaTime)
{
	float forward;
	float side;
	float fly;

	// Do not let the player control movement
	//  if not onground.
	onground = MO.Origin.z <= MO.FloorZ || EntityEx(MO).bOnMobj;

	forward = ForwardMove * 5.0;
	side = SideMove * 5.0;

	PlayerPawn(MO).AdjustSpeed(forward, side);

	if (!onground && !MO.bNoGravity && !MO.WaterLevel)
	{
		//  not on ground, so we have little effect on velocity
		forward *= Level.AirControl;
		side *= Level.AirControl;
	}

	if (forward)
	{
		ThrustPlayer(MO.Angles.yaw, forward, deltaTime);
	}
	if (side)
	{
		ThrustPlayer(AngleMod360(MO.Angles.yaw - 90.0), side, deltaTime);
	}

	if (forward || side)
	{
		SetPlayerRunState();

		if (bRevertCamera)
		{
			Camera = MO;
			bRevertCamera = false;
		}
	}

	fly = FlyMove / 16.0;
	if (fly && bFly)
	{
		if (FlyMove != TOCENTRE)
		{
			FlyHeight = fly * 2.0;
			if (!MO.bFly)
			{
				MO.bFly = true;
				MO.bNoGravity = true;
				if (MO.Velocity.z <= -39.0 * 35.0)
				{
					// stop falling scream
					MO.StopSound(CHAN_VOICE);
				}
			}
		}
		else
		{
			MO.bFly = false;
			MO.bNoGravity = false;
		}
	}
	else if (fly > 0.0)
	{
		//UseFlyPower();
	}
	if (MO.bFly)
	{
		MO.Velocity.z = FlyHeight * 35.0;
		if (FlyHeight)
		{
			FlyHeight /= 2.0;
		}
	}

	if ((Buttons & BT_JUMP) && onground && !JumpTime)
	{
		if (Cheats & CF_HIGHJUMP)
		{
			MO.Velocity.z = (PlayerPawn(MO).JumpVelZ * 2.0) * 1.1;
		}
		else
		{
			MO.Velocity.z = PlayerPawn(MO).JumpVelZ * 1.1;
		}
		EntityEx(MO).bOnMobj = false;
		JumpTime = 0.5;
	}
}

//==========================================================================
//
//  CheckWaterJump
//
//==========================================================================

final void CheckWaterJump()
{
	TVec start;
	TVec end;
	TVec vforward;
	TVec HitPoint;
	TVec HitNormal;

	// check for a jump-out-of-water
	AngleVector(&MO.Angles, &vforward);
	start = MO.Origin;
	start.z += MO.Height * 0.5 + 8.0;
	vforward.z = 0.0;
	vforward = Normalise(vforward);
	end = start + vforward * 24.0;
	if (!Level.XLevel.TraceLine(start, end, HitPoint, HitNormal))
	{
		// solid at waist
		start.z = MO.Origin.z + MO.Height;
		end = start + vforward * 24.0;
		MoveDir = HitNormal * -50.0;
		if (Level.XLevel.TraceLine(start, end, HitPoint, HitNormal))
		{
			// open at eye level
			EntityEx(MO).bWaterJump = true;
			MO.Velocity.z = 350.0;
			EntityEx(MO).ReactionTime = 2.0;	// safety net
		}
	}
}

//==========================================================================
//
//  WaterMove
//
//==========================================================================

final void WaterMove(float deltaTime)
{
	float forward;
	float side;
	TVec vforward;
	TVec vright;
	TVec vup;
	TVec wishvel;

	// Do not let the player control movement
	//  if not onground.
	onground = (MO.Origin.z <= MO.FloorZ) || EntityEx(MO).bOnMobj;

	AngleVectors(&MO.Angles, &vforward, &vright, &vup);

	forward = ForwardMove;
	side = SideMove;

	PlayerPawn(MO).AdjustSpeed(forward, side);

	wishvel = vforward * forward + vright * side;
	if (!forward && !side /* && !cmd.upmove */ )
		wishvel.z -= 60.0;	// drift towards bottom
//  else
//      wishvel.z += cmd.upmove;

	MO.Velocity += 3.5 * deltaTime * wishvel;

	if (forward || side)
	{
		SetPlayerRunState();
	}

	if (Buttons & BT_JUMP)
	{
		if (MO.WaterType == CONTENTS_WATER)
			MO.Velocity.z = 100.0;
		else if (MO.WaterType == CONTENTS_NUKAGE ||
			MO.WaterType == CONTENTS_SLIME || MO.WaterType == CONTENTS_SLUDGE)
			MO.Velocity.z = 80.0;
		else
			MO.Velocity.z = 50.0;
	}
	CheckWaterJump();
}

//==========================================================================
//
//  WaterJump
//
//==========================================================================

final void WaterJump()
{
	if (!EntityEx(MO).ReactionTime || !MO.WaterLevel)
	{
		EntityEx(MO).bWaterJump = false;
		EntityEx(MO).ReactionTime = 0.0;
	}
	MO.Velocity.x = MoveDir.x;
	MO.Velocity.y = MoveDir.y;
}

//==========================================================================
//
//  PlayerInSpecialSector
//
//  Called every tic frame that the player origin is in a special sector.
//
//==========================================================================

final void PlayerInSpecialSector(float deltaTime)
{
	float speed;
	float finean;

	if (MO.Origin.z != GetPlanePointZ(&MO.Sector->floor, MO.Origin) &&
		!MO.WaterLevel)
	{
		// Player is not touching the floor
		return;
	}

	if (MO.Sector->special & SECSPEC_SECRET_MASK)
	{
		//	Secret area.
		SecretCount++;
		Level.CurrentSecret++;
		MO.Sector->special &= ~SECSPEC_SECRET_MASK;
		centreprint("You found a secret area");
		MO.PlaySound('misc/secret', CHAN_VOICE);
	}

	if (MO.Sector->special >= SECSPEC_LightFlicker &&
		MO.Sector->special <= 255)
	{
		switch (MO.Sector->special)
		{
		case SECSPEC_DamageHellslime:
			if (
				Level.XLevel.Time - LastSectorDamageTime >= 32.0 / 35.0)
			{
				LastSectorDamageTime = Level.XLevel.Time;
				//EntityEx(MO).Damage(none, none, 10, 'Slime');
			}
			break;
		case SECSPEC_DamageSludge:
			if (
				Level.XLevel.Time - LastSectorDamageTime >= 32.0 / 35.0)
			{
				LastSectorDamageTime = Level.XLevel.Time;
				//EntityEx(MO).Damage(none, none, 4);
			}
			break;
		case SECSPEC_DamageNukage:
			if (
				Level.XLevel.Time - LastSectorDamageTime >= 32.0 / 35.0)
			{
				LastSectorDamageTime = Level.XLevel.Time;
				//EntityEx(MO).Damage(none, none, 5, 'Slime');
			}
			break;
		case SECSPEC_LightStrobeFastDamage:
		case SECSPEC_DamageSuperHellslime:
			if ((P_Random() < 5 && P_Random() < 5))
			{
				if (Level.XLevel.Time - LastSectorDamageTime >= 32.0 / 35.0)
				{
					LastSectorDamageTime = Level.XLevel.Time;
					//EntityEx(MO).Damage(none, none, 20, 'Slime');
				}
			}
			break;
		case SECSPEC_DamageSuperHellslimeExit:
			// EXIT SUPER DAMAGE! (for E1M8 finale)
			Cheats &= ~CF_GODMODE;
	
			if (Level.XLevel.Time - LastSectorDamageTime >= 32.0 / 35.0)
			{
				LastSectorDamageTime = Level.XLevel.Time;
				//EntityEx(MO).Damage(none, none, 20);
			}
	
			if (Health <= 10)
			{
				Level.ExitLevel(0);
			}
			break;
		case SECSPEC_DamageLavaWimpy:
			if (Level.XLevel.Time - LastSectorDamageTime >= 16.0 / 35.0)
			{
				LastSectorDamageTime = Level.XLevel.Time;
				//EntityEx(MO).Damage(none, none, 5, 'Fire');
				EntityEx(MO).HitFloorType();
			}
			break;
		case SECSPEC_DamageLavaHefty:
			if (Level.XLevel.Time - LastSectorDamageTime >= 16.0 / 35.0)
			{
				LastSectorDamageTime = Level.XLevel.Time;
				//EntityEx(MO).Damage(none, none, 8, 'Fire');
				EntityEx(MO).HitFloorType();
			}
			break;
		case SECSPEC_ScrollEastLavaDamage:
			ThrustPlayer(0.0, 1024.0, deltaTime);
			if (Level.XLevel.Time - LastSectorDamageTime >= 16.0 / 35.0)
			{
				LastSectorDamageTime = Level.XLevel.Time;
				//EntityEx(MO).Damage(none, none, 5, 'Fire');
				EntityEx(MO).HitFloorType();
			}
			break;
		case SECSPEC_DamageHazard:
				HazardTime += 2.0 * deltaTime;
			break;
		case SECSPEC_DamageInstantDeath:
			//EntityEx(MO).Damage(none, none, 999, 'InstantDeath');
			break;
		case SECSPEC_DamageSuperHazard:
				HazardTime += 4.0 * deltaTime;
			break;
		}
	}
	else
	{
		//	Extended sector damage type.
		switch (MO.Sector->special & SECSPEC_DAMAGE_MASK)
		{
		case 0x0100:
			if (
				Level.XLevel.Time - LastSectorDamageTime >= 32.0 / 35.0)
			{
				LastSectorDamageTime = Level.XLevel.Time;
				//EntityEx(MO).Damage(none, none, 5, 'Fire');
			}
			break;
		case 0x0200:
			if (
				Level.XLevel.Time - LastSectorDamageTime >= 32.0 / 35.0)
			{
				LastSectorDamageTime = Level.XLevel.Time;
				//EntityEx(MO).Damage(none, none, 10, 'Slime');
			}
			break;
		case 0x0300:
			if (P_Random() < 5 && P_Random() < 5)
			{
				if (Level.XLevel.Time - LastSectorDamageTime >= 32.0 / 35.0)
				{
					LastSectorDamageTime = Level.XLevel.Time;
					//EntityEx(MO).Damage(none, none, 20, 'Slime');
				}
			}
			break;
		}
	}

	//	Apply any customizable damage
	if (MO.Sector->Damage)
	{
		if (MO.Sector->Damage < 20)
		{
			if (
				Level.XLevel.Time - LastSectorDamageTime >= 32.0 / 35.0)
			{
				LastSectorDamageTime = Level.XLevel.Time;
				//EntityEx(MO).Damage(none, none, MO.Sector->Damage);
			}
		}
		else if (MO.Sector->Damage < 50)
		{
			if (P_Random() < 5 && P_Random() < 5)
			{
				if (Level.XLevel.Time - LastSectorDamageTime >= 32.0 / 35.0)
				{
					LastSectorDamageTime = Level.XLevel.Time;
					//EntityEx(MO).Damage(none, none, MO.Sector->Damage);
				}
			}
		}
		else if (Level.XLevel.Time - LastSectorDamageTime >= 1.0 / 35.0)
		{
			LastSectorDamageTime = Level.XLevel.Time;
			//EntityEx(MO).Damage(none, none, MO.Sector->Damage);
		}
	}

	switch (MO.Sector->special & SECSPEC_BASE_MASK)
	{
	case SECSPEC_ScrollCurrent:
		speed = itof((MO.Sector->tag - 100) % 10) / 16.0 * 35.0;
		finean = itof((MO.Sector->tag - 100) / 10) * 45.0;
		MO.Velocity.x += speed * cos(finean);
		MO.Velocity.y += speed * sin(finean);
		break;
	case SECSPEC_ScrollNorthSlow:
	case SECSPEC_ScrollNorthMedium:
	case SECSPEC_ScrollNorthFast:
		ThrustPlayer(90.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special &
			SECSPEC_BASE_MASK) - SECSPEC_ScrollNorthSlow], deltaTime);
		break;
	case SECSPEC_ScrollEastSlow:
	case SECSPEC_ScrollEastMedium:
	case SECSPEC_ScrollEastFast:
		ThrustPlayer(0.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special &
			SECSPEC_BASE_MASK) - SECSPEC_ScrollEastSlow], deltaTime);
		break;
	case SECSPEC_ScrollSouthSlow:
	case SECSPEC_ScrollSouthMedium:
	case SECSPEC_ScrollSouthFast:
		ThrustPlayer(270.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special &
			SECSPEC_BASE_MASK) - SECSPEC_ScrollSouthSlow], deltaTime);
		break;
	case SECSPEC_ScrollWestSlow:
	case SECSPEC_ScrollWestMedium:
	case SECSPEC_ScrollWestFast:
		ThrustPlayer(180.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special &
			SECSPEC_BASE_MASK) - SECSPEC_ScrollWestSlow], deltaTime);
		break;
	case SECSPEC_ScrollNorthWestSlow:
	case SECSPEC_ScrollNorthWestMedium:
	case SECSPEC_ScrollNorthWestFast:
		ThrustPlayer(135.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special &
			SECSPEC_BASE_MASK) - SECSPEC_ScrollNorthWestSlow], deltaTime);
		break;
	case SECSPEC_ScrollNorthEastSlow:
	case SECSPEC_ScrollNorthEastMedium:
	case SECSPEC_ScrollNorthEastFast:
		ThrustPlayer(45.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special &
			SECSPEC_BASE_MASK) - SECSPEC_ScrollNorthEastSlow], deltaTime);
		break;
	case SECSPEC_ScrollSouthEastSlow:
	case SECSPEC_ScrollSouthEastMedium:
	case SECSPEC_ScrollSouthEastFast:
		ThrustPlayer(315.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special &
			SECSPEC_BASE_MASK) - SECSPEC_ScrollSouthEastSlow], deltaTime);
		break;
	case SECSPEC_ScrollSouthWestSlow:
	case SECSPEC_ScrollSouthWestMedium:
	case SECSPEC_ScrollSouthWestFast:
		ThrustPlayer(225.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special &
			SECSPEC_BASE_MASK) - SECSPEC_ScrollSouthWestSlow], deltaTime);
		break;
	case SECSPEC_ScrollEast5:
	case SECSPEC_ScrollEast10:
	case SECSPEC_ScrollEast25:
	case SECSPEC_ScrollEast30:
	case SECSPEC_ScrollEast35:
		ThrustPlayer(0.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special &
			SECSPEC_BASE_MASK) - SECSPEC_ScrollEast5], deltaTime);
		break;
	case SECSPEC_ScrollNorth5:
	case SECSPEC_ScrollNorth10:
	case SECSPEC_ScrollNorth25:
	case SECSPEC_ScrollNorth30:
	case SECSPEC_ScrollNorth35:
		ThrustPlayer(90.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special &
			SECSPEC_BASE_MASK) - SECSPEC_ScrollNorth5], deltaTime);
		break;
	case SECSPEC_ScrollSouth5:
	case SECSPEC_ScrollSouth10:
	case SECSPEC_ScrollSouth25:
	case SECSPEC_ScrollSouth30:
	case SECSPEC_ScrollSouth35:
		ThrustPlayer(270.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special &
			SECSPEC_BASE_MASK) - SECSPEC_ScrollSouth5], deltaTime);
		break;
	case SECSPEC_ScrollWest5:
	case SECSPEC_ScrollWest10:
	case SECSPEC_ScrollWest25:
	case SECSPEC_ScrollWest30:
	case SECSPEC_ScrollWest35:
		ThrustPlayer(180.0, LineSpecialGameInfo(Level.Game).pushTab[(MO.Sector->special &
			SECSPEC_BASE_MASK) - SECSPEC_ScrollWest5], deltaTime);
		break;
	};
}

//============================================================================
//
//  PlayerOnSpecialFlat
//
//============================================================================

final void PlayerOnSpecialFlat(VTerrainInfo* floorType)
{
	if (MO.Origin.z != MO.FloorZ)
	{
		// Player is not touching the floor
		return;
	}

	if (floorType->bAllowProtection)
	{
	}

	if (floorType->DamageAmount && Level.XLevel.Time - LastSectorDamageTime >=
		itof(floorType->DamageTimeMask + 1) / 35.0)
	{
		LastSectorDamageTime = Level.XLevel.Time;
		//EntityEx(MO).Damage(none, none, 10, 'Fire');
		MO.PlaySound('world/lavasizzle', CHAN_BODY);
	}
}

//==========================================================================
//
//  PlayerInContents
//
//==========================================================================

final void PlayerInContents(float deltaTime)
{
	if (!MO.WaterLevel)
	{
		return;
	}


	switch (MO.WaterType)
	{
	case CONTENTS_LAVA:
		if (
			Level.XLevel.Time - LastSectorDamageTime >= 32.0 / 35.0)
		{
			LastSectorDamageTime = Level.XLevel.Time;
			//EntityEx(MO).Damage(none, none, 10, 'Fire');
		}
		break;

	case CONTENTS_NUKAGE:
		if (
			Level.XLevel.Time - LastSectorDamageTime >= 32.0 / 35.0)
		{
			LastSectorDamageTime = Level.XLevel.Time;
			//EntityEx(MO).Damage(none, none, 5);
		}
		break;

	case CONTENTS_SLIME:
		if (
			Level.XLevel.Time - LastSectorDamageTime >= 32.0 / 35.0)
		{
			LastSectorDamageTime = Level.XLevel.Time;
			//EntityEx(MO).Damage(none, none, 10);
		}
		break;

	case CONTENTS_HELLSLIME:
		if ((P_Random() < 5) &&
			Level.XLevel.Time - LastSectorDamageTime >= 32.0 / 35.0)
		{
			LastSectorDamageTime = Level.XLevel.Time;
			//EntityEx(MO).Damage(none, none, 20);
		}
		break;

	case CONTENTS_SLUDGE:
		if (
			Level.XLevel.Time - LastSectorDamageTime >= 32.0 / 35.0)
		{
			LastSectorDamageTime = Level.XLevel.Time;
			//EntityEx(MO).Damage(none, none, 4);
		}
		break;

	case CONTENTS_HAZARD:
			HazardTime += 2.0 * deltaTime;
		break;
	}
}

//==========================================================================
//
//  SetPlayerRunState
//
//==========================================================================

final void SetPlayerRunState()
{
	if (MO.State == EntityEx(MO).IdleState)
	{
		MO.SetState(EntityEx(MO).SeeState);
	}
}


//===========================================================================
//
//  SetupPsprites
//
//  Called at start of level for each player.
//
//===========================================================================

final void SetupPsprites()
{
	int i;

	// remove all psprites
	for (i = 0; i < NUMPSPRITES; i++)
	{
		SetViewState(i, none);
	}

}

//==========================================================================
//
//  MovePsprites
//
//  Called every tic by player thinking routine.
//
//==========================================================================

void MovePsprites(float deltaTime)
{
	AdvanceViewStates(deltaTime);
	ViewStates[ps_flash].SX = ViewStates[ps_weapon].SX;
	ViewStates[ps_flash].SY = ViewStates[ps_weapon].SY;
}


//==========================================================================
//
//  AddRevealedMap
//
//==========================================================================

final bool AddRevealedMap()
{
	int			i;

	bAutomapRevealed = true;
	for (i = 0; i < RevealedMaps.Num; i++)
	{
		if (RevealedMaps[i] == Level.XLevel.MapName)
		{
			//	Already revealed.
			return false;
		}
	}
	RevealedMaps.Num = RevealedMaps.Num + 1;
	RevealedMaps[RevealedMaps.Num - 1] = Level.XLevel.MapName;
	return true;
}

//==========================================================================
//
//  RemoveRevealedMap
//
//==========================================================================

final void RemoveRevealedMap()
{
	int			i;

	bAutomapRevealed = false;
	for (i = 0; i < RevealedMaps.Num; i++)
	{
		if (RevealedMaps[i] == Level.XLevel.MapName)
		{
			RevealedMaps.Remove(i);
			return;
		}
	}
}

//==========================================================================
//
//  UpdateRevealedMap
//
//==========================================================================

final void UpdateRevealedMap()
{
	int			i;

	bAutomapRevealed = false;
	for (i = 0; i < RevealedMaps.Num; i++)
	{
		if (RevealedMaps[i] == Level.XLevel.MapName)
		{
			bAutomapRevealed = true;
			return;
		}
	}
}

//==========================================================================
//
//  ParticleEffect
//
//==========================================================================

void ParticleEffect(int count, int type1, int type2, TVec origin, float ornd,
	TVec velocity, float vrnd, float acceleration, float grav, int colour, float duration, float ramp)
{
	Level.ParticleEffect(count, type1, type2, origin, ornd, velocity, vrnd, acceleration,
				grav, colour, duration, ramp);
}

//==========================================================================
//
//  ClientExplosion
//
//==========================================================================

void ClientExplosion(int colour, float rad, TVec org)
{
	dlight_t*	dl;

	dl = Level.AllocDlight(none);
	dl->origin = org;
	dl->radius = rad + 150.0;
	dl->colour = colour;
	dl->die = Level.XLevel.Time + 0.5;
	dl->decay = 300.0;
}

//==========================================================================
//
//  ClientParticleExplosion
//
//==========================================================================

void ClientParticleExplosion(int colour, float rad, TVec org)
{
	int i;
	particle_t *p;
	dlight_t *dl;

	for (i = 0; i < 1024; i++)
	{
		p = Level.NewParticle();
		if (!p)
			return;
		p->die = Level.XLevel.Time + 5.0;
		p->colour = LineSpecialGameInfo.default.ramp1[0];
		p->Size = 1.0;
		p->ramp = Random() * 4.0;
		if (i & 1)
		{
			p->type = LineSpecialLevelInfo::pt_explode;
		}
		else
		{
			p->type = LineSpecialLevelInfo::pt_explode2;
		}
		p->org.x = org.x + ((Random() * 32.0) - 16.0);
		p->org.y = org.y + ((Random() * 32.0) - 16.0);
		p->org.z = org.z + ((Random() * 32.0) - 16.0);
		p->vel.x = (Random() * 512.0) - 256.0;
		p->vel.y = (Random() * 512.0) - 256.0;
		p->vel.z = (Random() * 512.0) - 256.0;
//		p->accel = (Random() * 512.0) - 256.0;
		p->gravity = 40.0 + (Random() * 512.0) - 256.0;
	}

	dl = Level.AllocDlight(none);
	dl->origin = org;
	dl->radius = rad + 150.0;
	dl->colour = colour;
	dl->die = Level.XLevel.Time + 0.5;
	dl->decay = 300.0;
}

//==========================================================================
//
//	ClientSparkParticles
//
//==========================================================================

void ClientSparkParticles(int Count, TVec Org, float Angle)
{
	int			i;

	for (i = 0; i < Count; i++)
	{
		particle_t *p = Level.NewParticle();
		if (!p)
		{
			break;
		}

		p->type = LineSpecialLevelInfo::pt_spark;
		p->Size = 0.5;
		p->colour = Random() < 0.5 ? RGBA(255, 120, 0, 255) :
			RGBA(255, 170, 0, 255);
		p->die = Level.XLevel.Time + 10.0 / 35.0;

		float an = Angle + Random() * 45.0;
		p->org.x = Org.x + (Random () * 15.0) * cos(an);
		p->org.y = Org.y + (Random () * 15.0) * sin(an);
		p->org.z = Org.z - Random () * 4.0;

		p->vel.x = (Random() - 0.5) * 2.0;
		p->vel.y = (Random() - 0.5) * 2.0;
		p->vel.z = (Random() - 0.5) * 2.0 - Random () * 70.0;

		p->accel.x = (Random() - 0.5) * 16.0 + (Random () - 0.5) * 35.0;
		p->accel.y = (Random() - 0.5) * 16.0 + (Random () - 0.5) * 35.0;
		p->accel.z = (Random() - 0.5) * 16.0 - 140.0;
	}
}

//==========================================================================
//
//	AddBlend
//
//==========================================================================

final void AddBlend(out float r, out float g, out float b, out float a,
	int Col)
{
	if (!(Col & 0xff000000))
	{
		//	No alpha
		return;
	}
	float r1 = itof((Col >> 16) & 0xff) / 255.0;
	float g1 = itof((Col >> 8) & 0xff) / 255.0;
	float b1 = itof(Col & 0xff) / 255.0;
	float a1 = itof((Col >> 24) & 0xff) / 255.0;
	float TmpA = 1.0 - (1.0 - a) * (1.0 - a1);
	if (!TmpA)
	{
		return;
	}
	r = (r * a * (1.0 - a1) + r1 * a1) / TmpA;
	g = (g * a * (1.0 - a1) + g1 * a1) / TmpA;
	b = (b * a * (1.0 - a1) + b1 * a1) / TmpA;
	a = TmpA;
}

//==========================================================================
//
//  PaletteFlash
//
//  Sets the new palette colour shift based upon the current values of
// Player.DamageFlash and Player.BonusFlash, contents and other inventory
// items.
//
//==========================================================================

void PaletteFlash()
{
	float r = 0.0;
	float g = 0.0;
	float b = 0.0;
	float a = 0.0;

	if (MO.WaterLevel == 3)
	{
		switch (MO.WaterType)
		{
		case CONTENTS_WATER:
			AddBlend(r, g, b, a, RGBA(130, 80, 50, 128));
			break;

		case CONTENTS_LAVA:
			AddBlend(r, g, b, a, RGBA(255, 80, 0, 150));
			break;

		case CONTENTS_NUKAGE:
			AddBlend(r, g, b, a, RGBA(50, 255, 50, 150));
			break;

		case CONTENTS_SLIME:
			AddBlend(r, g, b, a, RGBA(0, 25, 5, 150));
			break;

		case CONTENTS_HELLSLIME:
			AddBlend(r, g, b, a, RGBA(255, 80, 0, 150));
			break;

		case CONTENTS_BLOOD:
			AddBlend(r, g, b, a, RGBA(160, 16, 16, 150));
			break;

		case CONTENTS_SLUDGE:
			AddBlend(r, g, b, a, RGBA(128, 160, 128, 150));
			break;

		case CONTENTS_HAZARD:
			AddBlend(r, g, b, a, RGBA(128, 160, 128, 128));
			break;
		}
	}

	if (EntityEx(MO).DamageType == 'Ice')
	{
		// Frozen player
		AddBlend(r, g, b, a, RGBA(2, 2, 255, 113));
	}
	else
	{
		if (DamageFlash)
		{
			int Amount = ftoi(114.0 * DamageFlash);
			if (Amount >= 228)
			{
				Amount = 228;
			}
			AddBlend(r, g, b, a, (Amount << 24) |
				(PlayerPawn(MO).DamageScreenColour & 0x00ffffff));
		}

		if (BonusFlash)
		{
			int Amount = ftoi(256.0 * BonusFlash);
			if (Amount >= 128)
			{
				Amount = 128;
			}
			AddBlend(r, g, b, a, RGBA(215, 186, 68, Amount));
		}

		if (PoisonCount)
		{
			int Amount = PoisonCount * 160 / 32;
			if (Amount >= 160)
			{
				Amount = 160;
			}
			AddBlend(r, g, b, a, RGBA(56, 118, 46, Amount));
		}

		//FIXME add hazard flash.
		if (HazardTime > 16.0 || ftoi(4.0 * HazardTime) & 1)
		{
			AddBlend(r, g, b, a, RGBA(0, 255, 0, 32));
		}
	}

	if (BlendA)
	{
		AddBlend(r, g, b, a, RGBA(ftoi(BlendR * 255.0), ftoi(BlendG * 255.0),
			ftoi(BlendB * 255.0), ftoi(BlendA * 255.0)));
	}

	if (r > 1.0)
	{
		r = 1.0;
	}
	if (g > 1.0)
	{
		g = 1.0;
	}
	if (b > 1.0)
	{
		b = 1.0;
	}
	CShift = RGBA(ftoi(r * 255.0), ftoi(g * 255.0), ftoi(b * 255.0),
		ftoi(a * 255.0));
}

//==========================================================================
//
//  PreTravel
//
//==========================================================================

void PreTravel()
{
}


//==========================================================================
//
//  CheckDoubleFiringSpeed
//
//==========================================================================

bool CheckDoubleFiringSpeed()
{
	return Cheats & CF_DOUBLEFIRINGSPEED;
}

//==========================================================================
//
//  ClientSpeech
//
//==========================================================================

void ClientSpeech(EntityEx Speaker, int SpeechNum)
{
	LineSpecialClientGame(ClGame).StartSpeech(Speaker, SpeechNum);
}

//==========================================================================
//
//  ClientSlideshow1
//
//==========================================================================

void ClientSlideshow1()
{
	LineSpecialClientGame(ClGame).StartConSlideshow1();
}

//==========================================================================
//
//  ClientSlideshow2
//
//==========================================================================

void ClientSlideshow2()
{
	LineSpecialClientGame(ClGame).StartConSlideshow2();
}

//==========================================================================
//
//  ClientFinaleType
//
//==========================================================================

void ClientFinaleType(int Type)
{
	LineSpecialClientGame(ClGame).SetFinaleType(Type);
}

//==========================================================================
//
//	SetObjectives
//
//==========================================================================

final void SetObjectives(int NewObjectives)
{
	if (!NewObjectives)
	{
		return;
	}
	//	Check if log text lump exists in wad file.
	if (!WadLumpPresent(StrToName(va("log%d", NewObjectives))))
	{
		return;
	}
	Objectives = NewObjectives;
}

//==========================================================================
//
//	DisplayObituary
//
//==========================================================================

void DisplayObituary(EntityEx inflictor, EntityEx source, name DmgType)
{
	string		Msg;

	if (DmgType == 'Suicide')
	{
		//	Commited a suicide
		Msg = "$ob_suicide";
	}
	else if (DmgType == 'Falling')
	{
		//	Fell down
		Msg = "$ob_falling";
	}
	else if (DmgType == 'Crush')
	{
		//	Crushed by the environment
		Msg = "$ob_crush";
	}
	else if (DmgType == 'Exit')
	{
		//	Tried to exit when it's not allowed
		Msg = "$ob_exit";
	}
	else if (DmgType == 'Drowning')
	{
		//	Drowned int the water
		Msg = "$ob_water";
	}
	else if (DmgType == 'Slime')
	{
		//	Was standing in the slime
		Msg = "$ob_slime";
	}
	else if (DmgType == 'Fire' && !source)
	{
		//	Was standing in the lava
		Msg = "$ob_lava";
	}
	else if (source)
	{
		if (source.Player == self)
		{
			//	Killed self
			Msg = "$ob_killedself";
		}
		else if (!source.bIsPlayer)
		{
			//	Killed by monster
			if (DmgType == 'Telefrag')
			{
				//	Monster telefrag
				Msg = "$ob_montelefrag";
			}
			else if (DmgType == 'Melee' && source.HitObituary)
			{
				Msg = source.HitObituary;
			}
			else
			{
				Msg = source.Obituary;
			}
		}
	}

	if (!Msg && source && source.bIsPlayer)
	{
		if (Level.Game.netgame && !Level.Game.deathmatch)
		{
			//	Killed another player in cooperative net game
			Msg = va("$ob_friendly%d", P_Random() & 3);
		}
		else if (DmgType == 'Telefrag')
		{
			//	Telefrag
			Msg = "$ob_mptelefrag";
		}
		else if (inflictor && inflictor.Obituary)
		{
			//	Missile with it's own obituary.
			Msg = inflictor.Obituary;
		}
		else
		{
		}
	}
	else
	{
		source = EntityEx(MO);
	}

	if (!Msg)
	{
		//	Generic death
		Msg = "$ob_default";
	}

	//	Look up string in language lump is necesary.
	if (StrStartsWith(Msg, "$"))
	{
		Msg = GetLangString(StrToName(substr(Msg, 1, strlen(Msg) - 1)));
	}

	//	Do replacements.
	Msg = StrReplace(Msg, "%g", "he");
	Msg = StrReplace(Msg, "%h", "him");
	Msg = StrReplace(Msg, "%p", "his");
	Msg = StrReplace(Msg, "%o", PlayerName);
	Msg = StrReplace(Msg, "%k", source.Player.PlayerName);

	Level.bprint("%s", Msg);
}

//==========================================================================
//
//	ClientRailTrail
//
//==========================================================================

void ClientRailTrail(TVec From, TVec To, int Col1, int Col2, float MaxDiff)
{
	float Len = Length(To - From);
	TVec Dir = Normalise(To - From);
	TAVec Ang;
	VectorAngles(&Dir, &Ang);
	Ang.roll = 270.0;

	if (!Col1)
	{
		Col1 = RGBA(255, 255, 255, 255);
	}
	if (!Col2)
	{
		Col2 = RGBA(0, 0, 255, 255);
	}

	TVec Diff;
	float Offs;
	for (Offs = 0.0; Offs < Len; Offs += 3.0)
	{
		if (MaxDiff > 0.0)
		{
			int Rnd = P_Random();
			if (Rnd & 1)
			{
				Diff.x += Rnd & 8 ? 1.0 : -1.0;
				if (Diff.x > MaxDiff)
				{
					Diff.x = MaxDiff;
				}
				else if (Diff.x < -MaxDiff)
				{
					Diff.x = -MaxDiff;
				}
			}
			if (Rnd & 2)
			{
				Diff.y += Rnd & 16 ? 1.0 : -1.0;
				if (Diff.y > MaxDiff)
				{
					Diff.y = MaxDiff;
				}
				else if (Diff.y < -MaxDiff)
				{
					Diff.y = -MaxDiff;
				}
			}
			if (Rnd & 4)
			{
				Diff.z += Rnd & 32 ? 1.0 : -1.0;
				if (Diff.z > MaxDiff)
				{
					Diff.z = MaxDiff;
				}
				else if (Diff.z < -MaxDiff)
				{
					Diff.z = -MaxDiff;
				}
			}
		}

		particle_t *p = Level.NewParticle();
		if (!p)
		{
			break;
		}
		p->type = LineSpecialLevelInfo::pt_rail;
		p->Size = 0.5;
		p->colour = Col1;
		p->die = Level.XLevel.Time + 1.0;
		p->org = From + Dir * Offs + Diff;
		p->vel.x = (Random() - 0.5) * 2.0;
		p->vel.y = (Random() - 0.5) * 2.0;
		p->vel.z = (Random() - 0.5) * 2.0;
		p->accel = vector(0.0, 0.0, 0.0);

		Ang.roll += 14.0;
		TVec Forward;
		TVec Right;
		TVec Up;
		AngleVectors(&Ang, &Forward, &Right, &Up);

		p = Level.NewParticle();
		if (!p)
		{
			break;
		}
		p->type = LineSpecialLevelInfo::pt_rail;
		p->Size = 0.5;
		p->colour = Col2;
		p->die = Level.XLevel.Time + 1.0;
		p->org = From + Dir * Offs + Up * 3.0;
		p->vel = Up;
		p->accel = vector(0.0, 0.0, 0.0);
	}
}

//==========================================================================
//
//  ClientVoice
//
//==========================================================================

void ClientVoice(int VoiceNum)
{
	LocalSound(StrToName(va("svox/voc%d", VoiceNum)));
}



//==========================================================================
//
//  PutClientIntoServer
//
//==========================================================================

void PutClientIntoServer()
{
	if (bIsBot)
	{
		CreateBot();
	}
}

//==========================================================================
//
//  SpawnClient
//
//==========================================================================

void SpawnClient()
{
	bool playerWasReborn;
	EntityEx OldMO = EntityEx(MO);

	Attacker = none;
	Poisoner = none;

	AddVisitedMap(Level.XLevel.MapName);

	if (Level.Game.netgame && !Level.Game.deathmatch)
	{
		// Cooperative net-play, retain keys and weapons
		playerWasReborn = (PlayerState == PST_REBORN);
	}

	//  Spawn player
	if (Level.Game.deathmatch)
	{
		DeathMatchSpawnPlayer();
	}
	else if (Level.Game.netgame || Level.bClusterHub)
	{
		SpawnPlayer(Level.GetPlayerStart(GetPlayerNum(),
			Level.Game.RebornPosition), false);
	}
	else
	{
		mthing_t* Best = NULL;
		bool Spawned = false;
		int i;
		for (i = 0; i < Level.PlayerStarts.Num; i++)
		{
			if (Level.PlayerStarts[i].type != GetPlayerNum() + 1)
			{
				continue;
			}
			if (Level.PlayerStarts[i].arg1 == Level.Game.RebornPosition)
			{
				SpawnPlayer(&Level.PlayerStarts[i], Spawned);
				Spawned = true;
				continue;
			}
			if (!Best)
			{
				Best = &Level.PlayerStarts[i];
			}
		}
		if (!Spawned)
		{
			if (!Best)
			{
				Error("Player %d has no start spots", GetPlayerNum() + 1);
			}
			print("Player %d has no start spot for position %d",
				GetPlayerNum() + 1, Level.Game.RebornPosition);
			SpawnPlayer(Best, false);
		}
	}

	if (Level.Game.netgame && !Level.Game.deathmatch && playerWasReborn)
	{
		OnNetReborn(OldMO);
	}

	// Destroy all things touching players
	Actor(MO).TeleportMove(MO.Origin);
}

//==========================================================================
//
//  NetGameReborn
//
//	Respawn at the start
//
//==========================================================================

void NetGameReborn()
{
	int i;
	bool foundSpot;
	EntityEx OldMO = EntityEx(MO);

	// remove pitch and roll angles from corpse
	MO.Angles.pitch = 0.0;
	MO.Angles.roll = 0.0;

	// first dissasociate the corpse
	MO.Player = none;
	MO.bIsPlayer = false;

	// spawn at random spot if in death match
	if (Level.Game.deathmatch)
	{
		DeathMatchSpawnPlayer();
		return;
	}

	foundSpot = false;
	if (CheckSpot(Level.GetPlayerStart(GetPlayerNum(),
		Level.Game.RebornPosition)))
	{
		// Appropriate player start spot is open
		SpawnPlayer(Level.GetPlayerStart(GetPlayerNum(),
			Level.Game.RebornPosition), false);
		foundSpot = true;
	}
	else
	{
		// Try to spawn at one of the other player start spots
		for (i = 0; i < MAXPLAYERS; i++)
		{
			if (CheckSpot(Level.GetPlayerStart(i, Level.Game.RebornPosition)))
			{
				// Found an open start spot
				SpawnPlayer(Level.GetPlayerStart(i, Level.Game.RebornPosition),
					false);
				foundSpot = true;
				break;
			}
		}
	}

	if (!foundSpot)
	{
		// Player's going to be inside something. Too bad.
		SpawnPlayer(Level.GetPlayerStart(GetPlayerNum(),
			Level.Game.RebornPosition), false);
	}

	OnNetReborn(OldMO);
}

//==========================================================================
//
//  DisconnectClient
//
//==========================================================================

void DisconnectClient()
{
	DestroyBot();
	if (MO)
	{
		MO.Player = none;
		MO.bIsPlayer = false;
	}
	Level.bprint("%s left the game\n", PlayerName);
	MO.PlaySound('misc/chat', CHAN_AUTO, 1.0, ATTN_NONE);
}

//==========================================================================
//
//  DeathMatchSpawnPlayer
//
//  Spawns a player at one of the random death match spots called at level
// load and each death
//
//==========================================================================

void DeathMatchSpawnPlayer()
{
	int i;
	int j;

	for (j = 0; j < 20; j++)
	{
		i = P_Random() % Level.DeathmatchStarts.Num;
		if (CheckSpot(&Level.DeathmatchStarts[i]))
		{
			SpawnPlayer(&Level.DeathmatchStarts[i], false);
			return;
		}
	}

	// no good spot, so the player will probably get stuck 
	SpawnPlayer(Level.GetPlayerStart(GetPlayerNum(), 0), false);
}

//==========================================================================
//
//  CheckSpot
//
//  Returns false if the player cannot be respawned at the given mthing_t
// spot because something is occupying it
//
//==========================================================================

bool CheckSpot(mthing_t * mthing)
{
	float x;
	float y;
	sector_t *sec;
	float an;
	int i;

	if (!MO)
	{
		// first spawn of level, before corpses
		for (i = 0; i < MAXPLAYERS; i++)
		{
			if (Level.Game.Players[i] && Level.Game.Players[i].MO &&
				Level.Game.Players[i].MO.Origin.x == mthing->x &&
				Level.Game.Players[i].MO.Origin.y == mthing->y)
			{
				return false;
			}
		}
		return true;
	}

	x = mthing->x;
	y = mthing->y;

	MO.bPassMobj = false;
	if (!MO.CheckPosition(vector(x, y, Actor::ONFLOORZ)))
	{
		MO.bPassMobj = true;
		return false;
	}
	MO.bPassMobj = true;

	if (!PlayerChunk(MO))
	{
		LineSpecialLevelInfo(Level).AddPlayerCorpse(EntityEx(MO));
	}

	// spawn a teleport fog 
	sec = Level.XLevel.PointInSector(vector(x, y, 0.0));
	an = itof(45 * (mthing->angle / 45));

	Level.Spawn(TeleportFog, vector(x + 20.0 * cos(an), y + 20.0 * sin(an),
		sec->floor.TexZ + LineSpecialGameInfo(Level.Game).TeleFogHeight));

	return true;
}

//==========================================================================
//
//  SetUpPlayerClass
//
//==========================================================================

void SetUpPlayerClass()
{
	if (LineSpecialGameInfo(Level.Game).bRandomClass &&
		Level.Game.deathmatch && Level.Game.PlayerClasses.Num > 1)
	{
		PClass = P_Random() % Level.Game.PlayerClasses.Num;
		if (PClass == BaseClass)
		{
			PClass = (PClass + 1) % Level.Game.PlayerClasses.Num;
		}
		BaseClass = PClass;
	}
	else
	{
		PClass = BaseClass;
	}
}

//==========================================================================
//
//  ResetPlayerOnSpawn
//
//==========================================================================

void ResetPlayerOnSpawn()
{
	PlayerState = PST_LIVE;
	Refire = 0;
	DamageFlash = 0.0;
	BonusFlash = 0.0;
	PoisonCount = 0;
	MorphTime = 0.0;
	ExtraLight = 0;
	FixedColourmap = 0;
	LastSectorDamageTime = 0.0;
	LastHazardTime = 0.0;
	Rain1 = none;
	Rain2 = none;
}

//==========================================================================
//
//  GiveDefaultDeathMatchInventory
//
//==========================================================================

//==========================================================================
//
//  SpawnPlayer
//
//  Called when a player is spawned on the level. Most of the player
// structure stays unchanged between levels.
//
//==========================================================================

void SpawnPlayer(mthing_t * mthing, bool Voodoo)
{
	float				x;
	float				y;
	float				z;
	PlayerPawn			PP;
	bool				ResetInventory = false;	

	if (PlayerState == PST_REBORN)
	{
		PlayerReborn();
		ResetInventory = true;
	}

	SetUpPlayerClass();

	x = mthing->x;
	y = mthing->y;
	z = Actor::ONFLOORZ;
	if (PClass >= Level.Game.PlayerClasses.Num)
	{
		Error("Player::SpawnPlayer : Unknown class type");
	}
	PP = Level.Spawn(class<PlayerPawn>(Level.Game.PlayerClasses[PClass]),
		vector(x, y, z),,, false);
	PP.Origin.z += mthing->height;
	PP.LinkToWorld();
	PP.FriendPlayer = GetPlayerNum() + 1;	//	Players are their own friends.

	//	Set colour translations for player sprites.
	TranslStart = PP.TranslStart;
	TranslEnd = PP.TranslEnd;
	PP.Translation = (Entity::TRANSL_Player << Entity::TRANSL_TYPE_SHIFT) +
		GetPlayerNum();

	DesiredFOV = 90.0; //itof(GetCvar('FOV'));
	FOV = DesiredFOV;
	PP.Angles.yaw = itof(45 * (mthing->angle / 45));
	PP.Player = self;
	PP.bIsPlayer = true;
	PP.Health = Health;
	MO = PP;
	Camera = PP;
	ViewHeight = PP.ViewHeight;
	ViewOrg = MO.Origin;
	ViewOrg.z += ViewHeight;
	ViewAngles = PP.Angles;
	bFixAngle = true;

	ResetPlayerOnSpawn();

	//	Set up gun psprite.
	SetupPsprites();


	if (bIsBot)
	{
		BotOnSpawn();
	}

	SetClientModel();

	UpdateRevealedMap();

	if (ResetInventory)
	{
		Level.XLevel.StartTypedACScripts(Level::SCRIPT_Respawn, 0, 0, 0, MO,
			true, false);
	}
}

//==========================================================================
//
//  PlayerReborn
//
//  Called after a player dies almost everything is cleared and initialised
//
//==========================================================================

void PlayerReborn()
{
	//  Clear player struct
	DoClearPlayer();

	PClass = BaseClass;

	//  Set initial data
	bUseDown = true;	// don't do anything immediately
	bAttackDown = true;
	PlayerState = PST_LIVE;
	Health = GetRebornHealth();
	LocalQuakeHappening = 0;
}

//==========================================================================
//
//  DoClearPlayer
//
//==========================================================================

void DoClearPlayer()
{
	ClearPlayer();
}

//==========================================================================
//
//  PlayerExitMap
//
//  Called when a player completes a level.
//
//==========================================================================

void PlayerExitMap(bool clusterChange)
{

	if (clusterChange)
	{
		// Entering new cluster
	}

	if (MorphTime)
	{
		MorphTime = 0.0;
	}

	MO.Angles.pitch = 0.0;
	MO.RenderStyle = Entity::STYLE_Normal;
	MO.Alpha = 1.0;
	EntityEx(MO).bShadow = false;	// cancel invisibility
	ExtraLight = 0;			// cancel gun flashes
	FixedColourmap = 0;		// cancel ir gogles
	DamageFlash = 0.0;		// no palette changes
	BonusFlash = 0.0;
	PoisonCount = 0;
	BlendR = 0.0;
	BlendG = 0.0;
	BlendB = 0.0;
	BlendA = 0.0;
	Rain1 = none;
	Rain2 = none;
}


//==========================================================================
//
//  DeathPlayerTick
//
//  Fall on your face when dying. Decrease POV height to floor height.
//
//==========================================================================

final void DeathPlayerTick(float deltaTime)
{
	int dir;
	float delta;

	MovePsprites(deltaTime);

	if (MO.WaterLevel > 1)
	{
		MO.Velocity.z = -60.0;	// drift towards bottom
	}

	onground = (MO.Origin.z <= MO.FloorZ);

	if (PlayerChunk(MO))
	{
		// Flying bloody skull or flying ice chunk
		ViewHeight = 6.0;
		DeltaViewHeight = 0.0;
		//damagecount = 20;
		if (onground)
		{
#ifdef FIXME
			if (lookdir < 60)
			{
				int lookDelta = (60 - lookdir) / 8;
				if (lookDelta < 1 && (level->tictime & 1))
				{
					lookDelta = 1;
				}
				else if (lookDelta > 6)
				{
					lookDelta = 6;
				}
				lookdir += lookDelta;
			}
#endif
		}
	}
	else if (Actor(MO).DamageType != 'Ice')
	{
		// Fall to ground (if not frozen)
		DeltaViewHeight = 0.0;
		if (ViewHeight > 6.0)
		{
			ViewHeight -= 35.0 * deltaTime;
		}
		if (ViewHeight < 6.0)
		{
			ViewHeight = 6.0;
		}
#ifdef FIXME
		if (lookdir > 0)
		{
			lookdir -= 6;
		}
		else if (lookdir < 0)
		{
			lookdir += 6;
		}
		if (abs(lookdir) < 6)
		{
			lookdir = 0;
		}
#endif
	}
	CalcHeight(deltaTime);

	if (Attacker && Attacker != MO)
	{
		// Watch killer
		dir = EntityEx(MO).FaceActor(EntityEx(Attacker), delta);
		if (delta < 10.0)
		{
			// Looking at killer, so fade damage and poison counters
			if (DamageFlash)
			{
				DamageFlash -= deltaTime;
				if (DamageFlash <= 0.0)
					DamageFlash = 0.0;
			}
			if (PoisonCount)
			{
				PoisonCount--;
			}
		}
		delta = delta / 8.0;
		if (delta > 5.0)
		{
			delta = 5.0;
		}
		if (dir)
		{
			// Turn clockwise
			MO.Angles.yaw += delta;
		}
		else
		{
			// Turn counter clockwise
			MO.Angles.yaw -= delta;
		}
	}
	else if (DamageFlash)
	{
		DamageFlash -= deltaTime;
		if (DamageFlash <= 0.0)
			DamageFlash = 0.0;
	}
	else if (PoisonCount)
	{
		PoisonCount--;
	}

	if (CheckForRespawn(deltaTime))
	{
		PlayerState = PST_REBORN;
	}
}

//==========================================================================
//
//  CheckForRespawn
//
//==========================================================================

bool CheckForRespawn(float deltaTime)
{
	return !!(Buttons & BT_USE);
}

//==========================================================================
//
//  PlayerTick
//
//==========================================================================

void PlayerTick(float deltaTime)
{
	if (bIsBot)
	{
		if (Level.bFrozen && !(Cheats & CF_TIMEFREEZE))
		{
			BotTick(deltaTime);
		}
	}

	if ((MO.XLevel.TicTime % (3 * 35) == 0) && Cheats & CF_REGENERATION && Health > 0)
	{
		if (EntityEx(MO).GiveBody(5) &&
			!GetSoundPlayingInfo(MO, GetSoundID('*regenerate')))
		{
			MO.PlaySound('*regenerate', CHAN_VOICE);
		}
	}

	if (Actor(MO).bJustAttacked)
	{
		ForwardMove = 100.0;
		SideMove = 0.0;
		Actor(MO).bJustAttacked = false;
	}

	//	You can only press use while totally frozen
	if (bTotallyFrozen || (Level.bFrozen && !(Cheats & CF_TIMEFREEZE)))
	{
		Buttons &= BT_USE;
		Impulse = 0;
		ViewAngles = MO.Angles;
		ForwardMove = 0.0;
		SideMove = 0.0;
		FlyMove = 0.0;
	}
	else if (bFrozen)
	{
		ForwardMove = 0.0;
		SideMove = 0.0;
		FlyMove = 0.0;
	}

	WorldTimer += deltaTime;	

	if (PlayerState == PST_DEAD)
	{
		DeathPlayerTick(deltaTime);
		return;
	}

	// Copy view angles
	if (MO == Camera)
	{
		MO.Angles = ViewAngles;
	}

	if (JumpTime)
	{
		JumpTime -= deltaTime;
		if (JumpTime <= 0.0)
		{
			JumpTime = 0.0;
		}
	}

	//	Move around.
	//	ReactionTime is used to prevent movement for a bit after a teleport.
	if (Actor(MO).ReactionTime)
	{
		Actor(MO).ReactionTime -= deltaTime;
		if (Actor(MO).ReactionTime <= 0.0)
			Actor(MO).ReactionTime = 0.0;
		if (Actor(MO).bWaterJump)
			WaterJump();
	}
	else
	{
		if (MO.WaterLevel > 1)
			WaterMove(deltaTime);
		else
			MovePlayer(deltaTime);
	}

	CalcHeight(deltaTime);

	if (MO.Sector->special || MO.Sector->Damage)
	{
		PlayerInSpecialSector(deltaTime);
	}
	PlayerOnSpecialFlat(Actor(MO).GetFloorType());
	PlayerInContents(deltaTime);

	if (MO.Velocity.z <= -35.0 * 35.0 && MO.Velocity.z >= -40.0 * 35.0 &&
		!MorphTime && MO.WaterLevel == 0 &&
		!GetSoundPlayingInfo(MO, GetSoundID('*falling')))
	{
		MO.PlaySound('*falling', CHAN_VOICE);
	}

	// Check for weapon change.
	if (Impulse)
	{
		PlayerImpulse();
	}

	// check for use
	if (Buttons & BT_USE)
	{
		if (!bUseDown)
		{
			EntityEx(MO).UseLines(USERANGE, USETHINGRANGE, '*usefail');
			bUseDown = true;
		}
	}
	else
	{
		bUseDown = false;
	}

	//	Cycle psprites
	MovePsprites(deltaTime);

	if (DamageFlash)
	{
		DamageFlash -= deltaTime;
		if (DamageFlash <= 0.0)
			DamageFlash = 0.0;
	}

	if (BonusFlash)
	{
		BonusFlash -= deltaTime;
		if (BonusFlash <= 0.0)
			BonusFlash = 0.0;
	}

	if (HazardTime)
	{
		HazardTime -= deltaTime;
		if (HazardTime <= 0.0)
			HazardTime = 0.0;
		if (Level.XLevel.Time - LastHazardTime >= 32.0 / 35.0 &&
			HazardTime > 16.0)
		{
			LastHazardTime = Level.XLevel.Time;
			//Actor(MO).Damage(none, none, 5);
		}
	}
	
	// [RH] Zoom the player's FOV
	float desired = DesiredFOV; // Default player FOV.
	
	if (FOV != desired)
	{
		if (fabs(FOV - desired) < 7.0)
		{
			FOV = desired;
		}
		else
		{
			float zoom = FMax(7.0, fabs(FOV - desired) * 0.025);

			if (FOV > desired)
			{
				FOV = FOV - zoom;
			}
			else
			{
				FOV = FOV + zoom;
			}
		}
		SetFOV(ftoi(FOV));
	}
}

//==========================================================================
//
//  SetViewPos
//
//==========================================================================

final void SetViewPos()
{
	//	Just in a case camera entity has been destroyed
	if (!Camera)
	{
		Camera = MO;
	}

	if (MO != Camera)
	{
		ViewOrg = Camera.Origin;
		ViewOrg.z += EntityEx(Camera).CameraHeight;
		ViewAngles = Camera.Angles;
	}
	else
	{
		ViewOrg.x = MO.Origin.x;
		ViewOrg.y = MO.Origin.y;

		if (LocalQuakeHappening)
		{
			float intensity;

			intensity = itof(LocalQuakeHappening);
			ViewOrg.x += (Random() - 0.5) * (intensity * 4.0);
			ViewOrg.y += (Random() - 0.5) * (intensity * 4.0);
		}

		if (PlayerState != PST_DEAD)
		{
			ViewAngles = MO.Angles;
		}
		else
		{
			ViewAngles.yaw = MO.Angles.yaw;
			ViewAngles.pitch = MO.Angles.pitch;
		}

		if (MorphTime && ChickenPeck)
		{
			// Set chicken attack view position
			ViewOrg.x += itof(ChickenPeck) * cos(MO.Angles.yaw);
			ViewOrg.y += itof(ChickenPeck) * sin(MO.Angles.yaw);
		}
	}

	PaletteFlash();

	ClientSetViewOrg(ViewOrg.x, ViewOrg.y, ViewOrg.z);

	SoundEnvironment = Level.XLevel.Zones[Camera.Sector->Zone];
	if (!SoundEnvironment)
	{
		if (Camera.WaterLevel >= 3)
		{
			//	Under water
			SoundEnvironment = 0x1600;
		}
		else
		{
			//	Generic
			SoundEnvironment = 1;
		}
	}
}

//==========================================================================
//
//  ClientTick
//
//==========================================================================

void ClientTick(float deltaTime)
{
	bAutoAim = !!GetCvar('autoaim');
}

//==========================================================================
//
//  AdjustPlayerAngle
//
//==========================================================================

final void AdjustPlayerAngle(EntityEx AimTarget)
{
	float angle;
	float difference;

	angle = atan2(AimTarget.Origin.y - MO.Origin.y,
		AimTarget.Origin.x - MO.Origin.x);
	difference = AngleMod180(angle - MO.Angles.yaw);
	if (fabs(difference) > 5.0)
	{
		MO.Angles.yaw += difference > 0.0 ? 5.0 : -5.0;
	}
	else
	{
		MO.Angles.yaw = angle;
	}
	bFixAngle = true;
}

//==========================================================================
//
//	AddVisitedMap
//
//==========================================================================

final void AddVisitedMap(name Map)
{
	int i;
	for (i = 0; i < MAX_MAPS_VISITED; i++)
	{
		if (MapsVisited[i] == Map)
		{
			return;
		}
		if (!MapsVisited[i])
		{
			MapsVisited[i] = Map;
			return;
		}
	}
}

//==========================================================================
//
//	GetMaxHealth
//
//==========================================================================

int GetMaxHealth()
{
	return 1000;
}

//==========================================================================
//
//  Cheat_God
//
//==========================================================================

final void Cheat_God()
{
	Cheats ^= CF_GODMODE;
	if (Cheats & CF_GODMODE)
	{
		if (LineSpecialGameInfo(Level.Game).GOD_HEALTH)
		{
			if (MO)
			{
				MO.Health = LineSpecialGameInfo(Level.Game).GOD_HEALTH;
			}
			Health = LineSpecialGameInfo(Level.Game).GOD_HEALTH;
			cprint("Degreelessness Mode On");
		}
		else
		{
			cprint("GOD MODE ON");
		}
	}
	else
	{
		if (LineSpecialGameInfo(Level.Game).GOD_HEALTH)
		{
			cprint("Degreelessness Mode Off");
		}
		else
		{
			cprint("GOD MODE OFF");
		}
	}
}

//==========================================================================
//
//  Cheat_NoClip
//
//==========================================================================

final void Cheat_NoClip()
{
	Cheats ^= CF_NOCLIP;
	if (Cheats & CF_NOCLIP)
	{
		MO.bColideWithThings = false;
		MO.bColideWithWorld = false;
		cprint("No Clipping Mode ON");
	}
	else
	{
		MO.bColideWithThings = true;
		MO.bColideWithWorld = true;
		cprint("No Clipping Mode OFF");
	}
}

//==========================================================================
//
//  Cheat_KillAll
//
//==========================================================================

final void Cheat_KillAll()
{
	cprint("%d MONSTERS KILLED", LineSpecialLevelInfo(Level).P_Massacre());
}


//==========================================================================
//
//  Cheat_Fly
//
//==========================================================================

final void Cheat_Fly()
{
	if (!bFly)
	{
		bFly = true;
		MO.bFly = true;
		MO.bNoGravity = true;
		if (MO.Origin.z <= MO.FloorZ)
		{
			// thrust the player in the air a bit
			FlyHeight = 10.0;
		}
		if (MO.Velocity.z <= -35.0 * 35.0)
		{
			// stop falling scream
			MO.StopSound(CHAN_VOICE);
		}
		cprint("You feel lighter");
	}
	else
	{
		if (MO.Origin.z != MO.FloorZ)
		{
//FIXME			player->centreing = true;
		}
		bFly = false;
		MO.bFly = false;
		MO.bNoGravity = false;
		cprint("Gravity weights you down");
	}
}

//==========================================================================
//
//  Cheat_NoTarget
//
//==========================================================================

final void Cheat_NoTarget()
{
	bNoTarget = !bNoTarget;
	if (bNoTarget)
	{
		cprint("No Target Mode ON");
	}
	else
	{
		cprint("No Target Mode OFF");
	}
}

//==========================================================================
//
//  Cheat_Anubis
//
//==========================================================================

final void Cheat_Anubis()
{
	Cheats ^= CF_FRIGHTENING;
	if (Cheats & CF_FRIGHTENING)
	{
		cprint("\"Quake with fear!\"");
	}
	else
	{
		cprint("No more ogre armor");
	}
}

//==========================================================================
//
//  Cheat_Freeze
//
//==========================================================================

final void Cheat_Freeze()
{
	Cheats ^= CF_TIMEFREEZE;
	if (Cheats & CF_TIMEFREEZE)
	{
		cprint("Freeze mode on");
		Level.bFrozen = true;
	}
	else
	{
		cprint("Freeze mode off");
		Level.bFrozen = false;
	}
}

bool CheckFriendlyFire(EntityEx source, int damage)
{
	return false;
}

bool IsWeaponAlwaysExtremeDeath()
{
	return false;
}

//==========================================================================
//
//  SetFOV
//
//  Zoom the player's FOV
//
//==========================================================================

final void SetFOV(int New_FOV)
{
	SetCvar('FOV', New_FOV);
}

void StartDeathSlideShow()
{
}


void Damaged(EntityEx inflictor)
{
}

void KilledActor(EntityEx Victim)
{
}

void Killed(EntityEx source, EntityEx inflictor)
{
}

int GetSigilPieces()
{
	return 0;
}

void PlayerMorphed(EntityEx OldMO)
{
}

void CreateBot()
{
}

void OnNetReborn(EntityEx OldMO)
{
}

void DestroyBot()
{
}

void BotOnSpawn()
{
}

void SetClientModel()
{
}

int GetRebornHealth()
{
	return 0;
}

void BotTick(float deltaTime)
{
}

void SpawnSpeedEffect()
{
}

void PlayerImpulse()
{
}

void PlayerUnmorphed()
{
}

defaultproperties
{
	InvSize = 6;
}
